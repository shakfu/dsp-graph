"""Python DSP simulator for dsp-graph signal graphs.

Runs a per-sample Python loop that mirrors the C++ code generated by
compile.py, enabling prototyping, unit-testing, and correctness verification
without compilation.

Usage::

    from dsp_graph.simulate import simulate, SimState, SimResult

Requires numpy (install via ``pip install dsp-graph[sim]``).
"""

from __future__ import annotations

import math
from dataclasses import dataclass, field
from typing import Any

try:
    import numpy as np
    from numpy.typing import NDArray
except ImportError as exc:
    raise ImportError(
        "numpy is required for simulation. Install with: pip install dsp-graph[sim]"
    ) from exc

from dsp_graph.models import (
    SVF,
    Accum,
    Allpass,
    BinOp,
    Biquad,
    Buffer,
    BufRead,
    BufSize,
    BufWrite,
    Change,
    Clamp,
    Compare,
    Constant,
    Counter,
    DCBlock,
    DelayLine,
    DelayRead,
    DelayWrite,
    Delta,
    Fold,
    Graph,
    History,
    Latch,
    Mix,
    Node,
    Noise,
    OnePole,
    Peek,
    Phasor,
    PulseOsc,
    RateDiv,
    SampleHold,
    SawOsc,
    Scale,
    Select,
    SinOsc,
    SmoothParam,
    TriOsc,
    UnaryOp,
    Wrap,
)
from dsp_graph.subgraph import expand_subgraphs
from dsp_graph.toposort import toposort
from dsp_graph.validate import validate_graph


class SimState:
    """Holds all mutable state for a simulated DSP graph."""

    def __init__(self, graph: Graph, sample_rate: float = 0.0) -> None:
        graph = expand_subgraphs(graph)
        errors = validate_graph(graph)
        if errors:
            raise ValueError("Invalid graph: " + "; ".join(errors))

        self._graph = graph
        self.sr = sample_rate if sample_rate > 0.0 else graph.sample_rate
        self._sorted_nodes = toposort(graph)
        self._params: dict[str, float] = {p.name: p.default for p in graph.params}
        self._state: dict[str, Any] = {}
        self._init_state()

    def _init_state(self) -> None:
        """Initialize node state, mirroring compile.py:_emit_state_init."""
        for node in self._sorted_nodes:
            nid = node.id
            if isinstance(node, History):
                self._state[nid] = node.init
            elif isinstance(node, DelayLine):
                self._state[f"{nid}.buf"] = np.zeros(node.max_samples, dtype=np.float32)
                self._state[f"{nid}.len"] = node.max_samples
                self._state[f"{nid}.wr"] = 0
            elif isinstance(node, Phasor):
                self._state[f"{nid}.phase"] = 0.0
            elif isinstance(node, Noise):
                self._state[f"{nid}.seed"] = np.uint32(123456789)
            elif isinstance(node, (Delta, Change)):
                self._state[f"{nid}.prev"] = 0.0
            elif isinstance(node, (Biquad, SVF)):
                self._state[f"{nid}.s1"] = 0.0
                self._state[f"{nid}.s2"] = 0.0
            elif isinstance(node, OnePole):
                self._state[f"{nid}.prev"] = 0.0
            elif isinstance(node, (DCBlock, Allpass)):
                self._state[f"{nid}.xprev"] = 0.0
                self._state[f"{nid}.yprev"] = 0.0
            elif isinstance(node, (SinOsc, TriOsc, SawOsc, PulseOsc)):
                self._state[f"{nid}.phase"] = 0.0
            elif isinstance(node, (SampleHold, Latch)):
                self._state[f"{nid}.held"] = 0.0
                self._state[f"{nid}.ptrig"] = 0.0
            elif isinstance(node, Accum):
                self._state[f"{nid}.sum"] = 0.0
            elif isinstance(node, Counter):
                self._state[f"{nid}.count"] = 0
                self._state[f"{nid}.ptrig"] = 0.0
            elif isinstance(node, RateDiv):
                self._state[f"{nid}.count"] = 0
                self._state[f"{nid}.held"] = 0.0
            elif isinstance(node, SmoothParam):
                self._state[f"{nid}.prev"] = 0.0
            elif isinstance(node, Peek):
                self._state[f"{nid}.value"] = 0.0
            elif isinstance(node, Buffer):
                self._state[f"{nid}.buf"] = np.zeros(node.size, dtype=np.float32)
                self._state[f"{nid}.len"] = node.size

    def reset(self) -> None:
        """Reset all state to initial values, mirroring compile.py:_emit_state_reset."""
        self._params = {p.name: p.default for p in self._graph.params}
        for node in self._sorted_nodes:
            nid = node.id
            if isinstance(node, History):
                self._state[nid] = node.init
            elif isinstance(node, DelayLine):
                buf = self._state[f"{nid}.buf"]
                buf[:] = 0.0
                self._state[f"{nid}.wr"] = 0
            elif isinstance(node, (Phasor, SinOsc, TriOsc, SawOsc, PulseOsc)):
                self._state[f"{nid}.phase"] = 0.0
            elif isinstance(node, Noise):
                self._state[f"{nid}.seed"] = np.uint32(123456789)
            elif isinstance(node, (Delta, Change)):
                self._state[f"{nid}.prev"] = 0.0
            elif isinstance(node, (Biquad, SVF)):
                self._state[f"{nid}.s1"] = 0.0
                self._state[f"{nid}.s2"] = 0.0
            elif isinstance(node, OnePole):
                self._state[f"{nid}.prev"] = 0.0
            elif isinstance(node, (DCBlock, Allpass)):
                self._state[f"{nid}.xprev"] = 0.0
                self._state[f"{nid}.yprev"] = 0.0
            elif isinstance(node, (SampleHold, Latch)):
                self._state[f"{nid}.held"] = 0.0
                self._state[f"{nid}.ptrig"] = 0.0
            elif isinstance(node, Accum):
                self._state[f"{nid}.sum"] = 0.0
            elif isinstance(node, Counter):
                self._state[f"{nid}.count"] = 0
                self._state[f"{nid}.ptrig"] = 0.0
            elif isinstance(node, RateDiv):
                self._state[f"{nid}.count"] = 0
                self._state[f"{nid}.held"] = 0.0
            elif isinstance(node, SmoothParam):
                self._state[f"{nid}.prev"] = 0.0
            elif isinstance(node, Peek):
                self._state[f"{nid}.value"] = 0.0
            elif isinstance(node, Buffer):
                buf = self._state[f"{nid}.buf"]
                buf[:] = 0.0

    def set_param(self, name: str, value: float) -> None:
        """Set a parameter value. Raises KeyError if name is unknown."""
        if name not in self._params:
            raise KeyError(f"Unknown param: '{name}'")
        self._params[name] = value

    def get_param(self, name: str) -> float:
        """Get current parameter value. Raises KeyError if name is unknown."""
        if name not in self._params:
            raise KeyError(f"Unknown param: '{name}'")
        return self._params[name]

    def set_buffer(self, buffer_id: str, data: NDArray[np.float32]) -> None:
        """Set buffer contents. Data is truncated/zero-padded to buffer size."""
        key = f"{buffer_id}.buf"
        if key not in self._state:
            raise KeyError(f"Unknown buffer: '{buffer_id}'")
        buf: NDArray[np.float32] = self._state[key]
        copy_len = min(len(data), len(buf))
        buf[:copy_len] = data[:copy_len]
        buf[copy_len:] = 0.0

    def get_buffer(self, buffer_id: str) -> NDArray[np.float32]:
        """Get a copy of buffer contents."""
        key = f"{buffer_id}.buf"
        if key not in self._state:
            raise KeyError(f"Unknown buffer: '{buffer_id}'")
        buf: NDArray[np.float32] = self._state[key]
        return buf.copy()

    def get_peek(self, peek_id: str) -> float:
        """Get the last value captured by a Peek node."""
        key = f"{peek_id}.value"
        if key not in self._state:
            raise KeyError(f"Unknown peek: '{peek_id}'")
        return float(self._state[key])


@dataclass
class SimResult:
    """Result of a simulation run."""

    outputs: dict[str, NDArray[np.float32]] = field(default_factory=dict)
    state: SimState = field(repr=False, default=None)  # type: ignore[assignment]


def simulate(
    graph: Graph,
    inputs: dict[str, NDArray[np.float32]] | None = None,
    n_samples: int = 0,
    params: dict[str, float] | None = None,
    state: SimState | None = None,
    sample_rate: float = 0.0,
) -> SimResult:
    """Simulate a DSP graph in Python, returning output arrays and state.

    Args:
        graph: The DSP graph to simulate.
        inputs: Dict mapping audio input IDs to float32 arrays. All arrays
            must have the same length. May be None for generators.
        n_samples: Number of samples to process. Inferred from inputs if 0.
            Required for generators (no inputs).
        params: Optional param overrides (name -> value).
        state: Optional SimState to reuse across calls. Created if None.
        sample_rate: Sample rate override. Uses graph.sample_rate if 0.

    Returns:
        SimResult with output arrays and the (possibly new) SimState.

    Raises:
        ValueError: On invalid graph, mismatched input shapes, etc.
    """
    if state is None:
        state = SimState(graph, sample_rate)

    # Apply param overrides
    if params:
        for name, value in params.items():
            state.set_param(name, value)

    # Determine n_samples
    input_ids = {inp.id for inp in state._graph.inputs}
    if inputs:
        lengths = set()
        for iid, arr in inputs.items():
            if iid not in input_ids:
                raise ValueError(f"Unknown input: '{iid}'")
            lengths.add(len(arr))
        if len(lengths) > 1:
            raise ValueError(f"Input arrays have mismatched lengths: {lengths}")
        inferred = lengths.pop() if lengths else 0
        if n_samples == 0:
            n_samples = inferred
        elif n_samples != inferred:
            raise ValueError(f"n_samples={n_samples} does not match input length {inferred}")
    elif n_samples == 0:
        raise ValueError("n_samples required when no inputs are provided")

    # Validate all required inputs are present
    if input_ids and (not inputs or set(inputs.keys()) != input_ids):
        provided = set(inputs.keys()) if inputs else set()
        missing = input_ids - provided
        if missing:
            raise ValueError(f"Missing inputs: {missing}")

    # Allocate output arrays
    output_arrays: dict[str, NDArray[np.float32]] = {}
    for out in state._graph.outputs:
        output_arrays[out.id] = np.zeros(n_samples, dtype=np.float32)

    # Pre-build lookup structures
    param_names = {p.name for p in state._graph.params}
    sorted_nodes = state._sorted_nodes

    # Sample loop
    for i in range(n_samples):
        vals: dict[str, float] = {}

        # Load input samples
        if inputs:
            for iid, arr in inputs.items():
                vals[iid] = float(arr[i])

        # Load param values
        for pname, pval in state._params.items():
            vals[pname] = pval

        # Load sr
        vals["sr"] = state.sr

        # Pre-load History values
        for node in sorted_nodes:
            if isinstance(node, History):
                vals[node.id] = float(state._state[node.id])

        # Track histories for deferred write-back
        history_nodes: list[History] = []

        # Compute nodes in topo order
        for node in sorted_nodes:
            _compute_node(node, vals, state, input_ids, param_names, history_nodes)

        # Deferred history write-backs (after all nodes computed)
        for h in history_nodes:
            state._state[h.id] = _resolve_ref(h.input, vals, input_ids, param_names)

        # Write outputs
        for out in state._graph.outputs:
            output_arrays[out.id][i] = np.float32(vals[out.source])

    return SimResult(outputs=output_arrays, state=state)


def _resolve_ref(
    ref: str | float,
    vals: dict[str, float],
    input_ids: set[str],
    param_names: set[str],
) -> float:
    """Resolve a Ref to a float value."""
    if isinstance(ref, float):
        return ref
    return vals[ref]


def _compute_node(
    node: Node,
    vals: dict[str, float],
    state: SimState,
    input_ids: set[str],
    param_names: set[str],
    history_nodes: list[History],
) -> None:
    """Compute a single node, updating vals and state in-place.

    Directly mirrors compile.py:_emit_node_compute.
    """
    nid = node.id

    def ref(r: str | float) -> float:
        return _resolve_ref(r, vals, input_ids, param_names)

    if isinstance(node, BinOp):
        a, b = ref(node.a), ref(node.b)
        if node.op == "add":
            vals[nid] = a + b
        elif node.op == "sub":
            vals[nid] = a - b
        elif node.op == "mul":
            vals[nid] = a * b
        elif node.op == "div":
            vals[nid] = a / b if b != 0.0 else 0.0
        elif node.op == "min":
            vals[nid] = min(a, b)
        elif node.op == "max":
            vals[nid] = max(a, b)
        elif node.op == "mod":
            vals[nid] = math.fmod(a, b) if b != 0.0 else 0.0
        elif node.op == "pow":
            vals[nid] = math.pow(a, b)

    elif isinstance(node, UnaryOp):
        a = ref(node.a)
        if node.op == "neg":
            vals[nid] = -a
        elif node.op == "sign":
            vals[nid] = 1.0 if a > 0.0 else (-1.0 if a < 0.0 else 0.0)
        elif node.op == "sin":
            vals[nid] = math.sin(a)
        elif node.op == "cos":
            vals[nid] = math.cos(a)
        elif node.op == "tanh":
            vals[nid] = math.tanh(a)
        elif node.op == "exp":
            vals[nid] = math.exp(a)
        elif node.op == "log":
            vals[nid] = math.log(a) if a > 0.0 else float("-inf")
        elif node.op == "abs":
            vals[nid] = abs(a)
        elif node.op == "sqrt":
            vals[nid] = math.sqrt(a) if a >= 0.0 else 0.0
        elif node.op == "floor":
            vals[nid] = math.floor(a)
        elif node.op == "ceil":
            vals[nid] = math.ceil(a)
        elif node.op == "round":
            vals[nid] = float(round(a))
        elif node.op == "atan":
            vals[nid] = math.atan(a)
        elif node.op == "asin":
            vals[nid] = math.asin(max(-1.0, min(1.0, a)))
        elif node.op == "acos":
            vals[nid] = math.acos(max(-1.0, min(1.0, a)))

    elif isinstance(node, Clamp):
        a, lo, hi = ref(node.a), ref(node.lo), ref(node.hi)
        vals[nid] = min(max(a, lo), hi)

    elif isinstance(node, Constant):
        vals[nid] = node.value

    elif isinstance(node, History):
        # Value already pre-loaded; track for deferred write-back
        history_nodes.append(node)

    elif isinstance(node, DelayLine):
        # State-only, no per-sample compute
        pass

    elif isinstance(node, DelayRead):
        dl = node.delay
        tap = ref(node.tap)
        buf: NDArray[np.float32] = state._state[f"{dl}.buf"]
        length: int = state._state[f"{dl}.len"]
        wr: int = state._state[f"{dl}.wr"]

        if node.interp == "none":
            pos = (wr - int(tap)) % length
            vals[nid] = float(buf[pos])
        elif node.interp == "linear":
            vals[nid] = _interp_linear_delay(tap, buf, length, wr)
        elif node.interp == "cubic":
            vals[nid] = _interp_cubic_delay(tap, buf, length, wr)

    elif isinstance(node, DelayWrite):
        dl = node.delay
        val = ref(node.value)
        buf = state._state[f"{dl}.buf"]
        wr = state._state[f"{dl}.wr"]
        length = state._state[f"{dl}.len"]
        buf[wr] = np.float32(val)
        state._state[f"{dl}.wr"] = (wr + 1) % length

    elif isinstance(node, Phasor):
        freq = ref(node.freq)
        phase = state._state[f"{nid}.phase"]
        vals[nid] = phase
        phase += freq / state.sr
        if phase >= 1.0:
            phase -= 1.0
        state._state[f"{nid}.phase"] = phase

    elif isinstance(node, Noise):
        seed = state._state[f"{nid}.seed"]
        with np.errstate(over="ignore"):
            seed = np.uint32(np.uint32(seed) * np.uint32(1664525) + np.uint32(1013904223))
        state._state[f"{nid}.seed"] = seed
        vals[nid] = float(np.int32(seed)) / 2147483648.0

    elif isinstance(node, Compare):
        a, b = ref(node.a), ref(node.b)
        if node.op == "gt":
            vals[nid] = 1.0 if a > b else 0.0
        elif node.op == "lt":
            vals[nid] = 1.0 if a < b else 0.0
        elif node.op == "gte":
            vals[nid] = 1.0 if a >= b else 0.0
        elif node.op == "lte":
            vals[nid] = 1.0 if a <= b else 0.0
        elif node.op == "eq":
            vals[nid] = 1.0 if a == b else 0.0

    elif isinstance(node, Select):
        cond = ref(node.cond)
        vals[nid] = ref(node.a) if cond > 0.0 else ref(node.b)

    elif isinstance(node, Wrap):
        a, lo, hi = ref(node.a), ref(node.lo), ref(node.hi)
        rng = hi - lo
        raw = math.fmod(a - lo, rng)
        if raw < 0.0:
            raw += rng
        vals[nid] = lo + raw

    elif isinstance(node, Fold):
        a, lo, hi = ref(node.a), ref(node.lo), ref(node.hi)
        rng = hi - lo
        t = math.fmod(a - lo, 2.0 * rng)
        if t < 0.0:
            t += 2.0 * rng
        vals[nid] = lo + t if t <= rng else hi - (t - rng)

    elif isinstance(node, Mix):
        a_v, b_v, t_v = ref(node.a), ref(node.b), ref(node.t)
        vals[nid] = a_v + (b_v - a_v) * t_v

    elif isinstance(node, Delta):
        a = ref(node.a)
        prev = state._state[f"{nid}.prev"]
        vals[nid] = a - prev
        state._state[f"{nid}.prev"] = a

    elif isinstance(node, Change):
        a = ref(node.a)
        prev = state._state[f"{nid}.prev"]
        vals[nid] = 1.0 if a != prev else 0.0
        state._state[f"{nid}.prev"] = a

    elif isinstance(node, Biquad):
        x = ref(node.a)
        b0, b1, b2 = ref(node.b0), ref(node.b1), ref(node.b2)
        a1, a2 = ref(node.a1), ref(node.a2)
        s1 = state._state[f"{nid}.s1"]
        s2 = state._state[f"{nid}.s2"]
        y = b0 * x + s1
        state._state[f"{nid}.s1"] = b1 * x - a1 * y + s2
        state._state[f"{nid}.s2"] = b2 * x - a2 * y
        vals[nid] = y

    elif isinstance(node, SVF):
        x = ref(node.a)
        freq = ref(node.freq)
        q = ref(node.q)
        sr = state.sr
        s1 = state._state[f"{nid}.s1"]
        s2 = state._state[f"{nid}.s2"]
        g = math.tan(3.14159265 * freq / sr)
        k = 1.0 / q
        a1 = 1.0 / (1.0 + g * (g + k))
        a2 = g * a1
        a3 = g * a2
        v3 = x - s2
        v1 = a1 * s1 + a2 * v3
        v2 = s2 + a2 * s1 + a3 * v3
        state._state[f"{nid}.s1"] = 2.0 * v1 - s1
        state._state[f"{nid}.s2"] = 2.0 * v2 - s2
        mode = node.mode
        if mode == "lp":
            vals[nid] = v2
        elif mode == "hp":
            vals[nid] = x - k * v1 - v2
        elif mode == "bp":
            vals[nid] = v1
        elif mode == "notch":
            vals[nid] = x - k * v1

    elif isinstance(node, OnePole):
        a = ref(node.a)
        c = ref(node.coeff)
        prev = state._state[f"{nid}.prev"]
        y = c * a + (1.0 - c) * prev
        state._state[f"{nid}.prev"] = y
        vals[nid] = y

    elif isinstance(node, DCBlock):
        x = ref(node.a)
        xprev = state._state[f"{nid}.xprev"]
        yprev = state._state[f"{nid}.yprev"]
        y = x - xprev + 0.995 * yprev
        state._state[f"{nid}.xprev"] = x
        state._state[f"{nid}.yprev"] = y
        vals[nid] = y

    elif isinstance(node, Allpass):
        x = ref(node.a)
        c = ref(node.coeff)
        xprev = state._state[f"{nid}.xprev"]
        yprev = state._state[f"{nid}.yprev"]
        y = c * (x - yprev) + xprev
        state._state[f"{nid}.xprev"] = x
        state._state[f"{nid}.yprev"] = y
        vals[nid] = y

    elif isinstance(node, SinOsc):
        freq = ref(node.freq)
        phase = state._state[f"{nid}.phase"]
        vals[nid] = math.sin(6.28318530 * phase)
        phase += freq / state.sr
        if phase >= 1.0:
            phase -= 1.0
        state._state[f"{nid}.phase"] = phase

    elif isinstance(node, TriOsc):
        freq = ref(node.freq)
        phase = state._state[f"{nid}.phase"]
        vals[nid] = 4.0 * abs(phase - 0.5) - 1.0
        phase += freq / state.sr
        if phase >= 1.0:
            phase -= 1.0
        state._state[f"{nid}.phase"] = phase

    elif isinstance(node, SawOsc):
        freq = ref(node.freq)
        phase = state._state[f"{nid}.phase"]
        vals[nid] = 2.0 * phase - 1.0
        phase += freq / state.sr
        if phase >= 1.0:
            phase -= 1.0
        state._state[f"{nid}.phase"] = phase

    elif isinstance(node, PulseOsc):
        freq = ref(node.freq)
        width = ref(node.width)
        phase = state._state[f"{nid}.phase"]
        vals[nid] = 1.0 if phase < width else -1.0
        phase += freq / state.sr
        if phase >= 1.0:
            phase -= 1.0
        state._state[f"{nid}.phase"] = phase

    elif isinstance(node, SampleHold):
        a = ref(node.a)
        t = ref(node.trig)
        ptrig = state._state[f"{nid}.ptrig"]
        held = state._state[f"{nid}.held"]
        if (ptrig <= 0.0 and t > 0.0) or (ptrig > 0.0 and t <= 0.0):
            held = a
        state._state[f"{nid}.ptrig"] = t
        state._state[f"{nid}.held"] = held
        vals[nid] = held

    elif isinstance(node, Latch):
        a = ref(node.a)
        t = ref(node.trig)
        ptrig = state._state[f"{nid}.ptrig"]
        held = state._state[f"{nid}.held"]
        if ptrig <= 0.0 and t > 0.0:
            held = a
        state._state[f"{nid}.ptrig"] = t
        state._state[f"{nid}.held"] = held
        vals[nid] = held

    elif isinstance(node, Accum):
        incr = ref(node.incr)
        reset = ref(node.reset)
        s = state._state[f"{nid}.sum"]
        if reset > 0.0:
            s = 0.0
        s += incr
        state._state[f"{nid}.sum"] = s
        vals[nid] = s

    elif isinstance(node, Counter):
        t = ref(node.trig)
        mx = ref(node.max)
        ptrig = state._state[f"{nid}.ptrig"]
        count = state._state[f"{nid}.count"]
        if ptrig <= 0.0 and t > 0.0:
            count += 1
            if count >= int(mx):
                count = 0
        state._state[f"{nid}.ptrig"] = t
        state._state[f"{nid}.count"] = count
        vals[nid] = float(count)

    elif isinstance(node, Buffer):
        # State-only, no per-sample compute
        pass

    elif isinstance(node, BufRead):
        buf_id = node.buffer
        idx = ref(node.index)
        buf = state._state[f"{buf_id}.buf"]
        buf_len: int = state._state[f"{buf_id}.len"]
        if node.interp == "none":
            ii = int(idx)
            ii = max(0, min(ii, buf_len - 1))
            vals[nid] = float(buf[ii])
        elif node.interp == "linear":
            vals[nid] = _interp_linear_buf(idx, buf, buf_len)
        elif node.interp == "cubic":
            vals[nid] = _interp_cubic_buf(idx, buf, buf_len)

    elif isinstance(node, BufWrite):
        buf_id = node.buffer
        idx = ref(node.index)
        val = ref(node.value)
        buf = state._state[f"{buf_id}.buf"]
        buf_len = state._state[f"{buf_id}.len"]
        ii = int(idx)
        if 0 <= ii < buf_len:
            buf[ii] = np.float32(val)

    elif isinstance(node, BufSize):
        buf_id = node.buffer
        vals[nid] = float(state._state[f"{buf_id}.len"])

    elif isinstance(node, RateDiv):
        a = ref(node.a)
        divisor = ref(node.divisor)
        count = state._state[f"{nid}.count"]
        held = state._state[f"{nid}.held"]
        if count == 0:
            held = a
        count += 1
        if count >= int(divisor):
            count = 0
        state._state[f"{nid}.count"] = count
        state._state[f"{nid}.held"] = held
        vals[nid] = held

    elif isinstance(node, Scale):
        a = ref(node.a)
        in_lo = ref(node.in_lo)
        in_hi = ref(node.in_hi)
        out_lo = ref(node.out_lo)
        out_hi = ref(node.out_hi)
        in_range = in_hi - in_lo
        out_range = out_hi - out_lo
        vals[nid] = out_lo + (a - in_lo) / in_range * out_range if in_range != 0.0 else out_lo

    elif isinstance(node, SmoothParam):
        a = ref(node.a)
        c = ref(node.coeff)
        prev = state._state[f"{nid}.prev"]
        y = (1.0 - c) * a + c * prev
        state._state[f"{nid}.prev"] = y
        vals[nid] = y

    elif isinstance(node, Peek):
        a = ref(node.a)
        vals[nid] = a
        state._state[f"{nid}.value"] = a


# ---------------------------------------------------------------------------
# Delay interpolation helpers
# ---------------------------------------------------------------------------


def _interp_linear_delay(
    tap: float,
    buf: NDArray[np.float32],
    length: int,
    wr: int,
) -> float:
    itap = int(tap)
    frac = tap - float(itap)
    i0 = (wr - itap) % length
    i1 = (wr - itap - 1) % length
    s0 = float(buf[i0])
    s1 = float(buf[i1])
    return s0 + frac * (s1 - s0)


def _interp_cubic_delay(
    tap: float,
    buf: NDArray[np.float32],
    length: int,
    wr: int,
) -> float:
    itap = int(tap)
    frac = tap - float(itap)
    i0 = (wr - itap) % length
    im1 = (i0 + 1) % length
    i1 = (wr - itap - 1) % length
    i2 = (wr - itap - 2) % length
    ym1 = float(buf[im1])
    y0 = float(buf[i0])
    y1 = float(buf[i1])
    y2 = float(buf[i2])
    c0 = y0
    c1 = 0.5 * (y1 - ym1)
    c2 = ym1 - 2.5 * y0 + 2.0 * y1 - 0.5 * y2
    c3 = 0.5 * (y2 - ym1) + 1.5 * (y0 - y1)
    return ((c3 * frac + c2) * frac + c1) * frac + c0


# ---------------------------------------------------------------------------
# Buffer interpolation helpers
# ---------------------------------------------------------------------------


def _clamp_buf_idx(idx: int, buf_len: int) -> int:
    if idx < 0:
        return 0
    if idx >= buf_len:
        return buf_len - 1
    return idx


def _interp_linear_buf(
    idx: float,
    buf: NDArray[np.float32],
    buf_len: int,
) -> float:
    i0 = int(idx)
    frac = idx - float(i0)
    i1 = i0 + 1
    i0 = _clamp_buf_idx(i0, buf_len)
    i1 = _clamp_buf_idx(i1, buf_len)
    s0 = float(buf[i0])
    s1 = float(buf[i1])
    return s0 + frac * (s1 - s0)


def _interp_cubic_buf(
    idx: float,
    buf: NDArray[np.float32],
    buf_len: int,
) -> float:
    i0 = int(idx)
    frac = idx - float(i0)
    im1 = _clamp_buf_idx(i0 - 1, buf_len)
    i0c = _clamp_buf_idx(i0, buf_len)
    i1 = _clamp_buf_idx(i0 + 1, buf_len)
    i2 = _clamp_buf_idx(i0 + 2, buf_len)
    ym1 = float(buf[im1])
    y0 = float(buf[i0c])
    y1 = float(buf[i1])
    y2 = float(buf[i2])
    c0 = y0
    c1 = 0.5 * (y1 - ym1)
    c2 = ym1 - 2.5 * y0 + 2.0 * y1 - 0.5 * y2
    c3 = 0.5 * (y2 - ym1) + 1.5 * (y0 - y1)
    return ((c3 * frac + c2) * frac + c1) * frac + c0
