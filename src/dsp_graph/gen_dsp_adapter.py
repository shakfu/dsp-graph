"""gen-dsp adapter: bridge dsp-graph output to gen-dsp platform backends.

Generates adapter C++ code that implements gen-dsp's ``_ext.h`` wrapper
interface by delegating to the dsp-graph compiled API.  Also generates
a ``manifest.json`` compatible with ``gen_dsp.core.manifest.Manifest``.
"""

from __future__ import annotations

import json
import shutil
from pathlib import Path

from dsp_graph.compile import _to_pascal, compile_graph
from dsp_graph.models import Buffer, Graph

# Platform key -> (common-header macro prefix, namespace suffix)
_PLATFORM_INFO: dict[str, tuple[str, str]] = {
    "chuck": ("CHUCK_EXT_NAME", "_chugin"),
    "clap": ("CLAP_EXT_NAME", "_clap"),
    "au": ("AU_EXT_NAME", "_au"),
    "vst3": ("VST3_EXT_NAME", "_vst3"),
    "lv2": ("LV2_EXT_NAME", "_lv2"),
    "sc": ("SC_EXT_NAME", "_sc"),
    "vcvrack": ("VCVRACK_EXT_NAME", "_vcvrack"),
    "daisy": ("DAISY_EXT_NAME", "_daisy"),
    "circle": ("CIRCLE_EXT_NAME", "_circle"),
    "pd": ("PD_EXT_NAME", "_pd"),
    "max": ("MAX_EXT_NAME", "_max"),
}

SUPPORTED_PLATFORMS = set(_PLATFORM_INFO.keys())


def generate_adapter_cpp(graph: Graph, platform: str) -> str:
    """Generate the ``_ext_{platform}.cpp`` adapter source.

    This replaces the genlib-side wrapper with dsp-graph calls while
    keeping gen-dsp's platform-side code unchanged.

    Args:
        graph: Compiled DSP graph.
        platform: gen-dsp platform key (e.g. ``"chuck"``, ``"clap"``).

    Returns:
        Complete C++ source as a string.

    Raises:
        ValueError: If *platform* is not a recognised gen-dsp platform.
    """
    if platform not in _PLATFORM_INFO:
        raise ValueError(f"Unknown platform {platform!r}; supported: {sorted(_PLATFORM_INFO)}")

    name = graph.name
    struct = _to_pascal(name) + "State"

    lines: list[str] = []
    w = lines.append

    w(f"// _ext_{platform}.cpp -- dsp-graph adapter for gen-dsp {platform} backend")
    w("// Generated by dsp-graph")
    w("")
    w(f'#include "gen_ext_common_{platform}.h"')
    w("")
    w("// Include dsp-graph compiled code")
    w(f'#include "{name}.cpp"')
    w("")
    w("typedef void GenState;")
    w("")
    w("namespace WRAPPER_NAMESPACE {")
    w("")

    # -- lifecycle
    w("GenState* wrapper_create(float sr, long bs) {")
    w("    (void)bs;")
    w(f"    return (GenState*){name}_create(sr);")
    w("}")
    w("")
    w("void wrapper_destroy(GenState* state) {")
    w(f"    {name}_destroy(({struct}*)state);")
    w("}")
    w("")
    w("void wrapper_reset(GenState* state) {")
    w(f"    {name}_reset(({struct}*)state);")
    w("}")
    w("")

    # -- perform
    w("void wrapper_perform(GenState* state, float** ins, long numins,")
    w("                     float** outs, long numouts, long n) {")
    w("    (void)numins; (void)numouts;")
    w(f"    {name}_perform(({struct}*)state, ins, outs, (int)n);")
    w("}")
    w("")

    # -- I/O counts
    w(f"int wrapper_num_inputs() {{ return {name}_num_inputs(); }}")
    w(f"int wrapper_num_outputs() {{ return {name}_num_outputs(); }}")
    w(f"int wrapper_num_params() {{ return {name}_num_params(); }}")
    w("")

    # -- param introspection
    w("const char* wrapper_param_name(GenState* state, int index) {")
    w("    (void)state;")
    w(f"    return {name}_param_name(index);")
    w("}")
    w("")
    w("const char* wrapper_param_units(GenState* state, int index) {")
    w("    (void)state; (void)index;")
    w('    return "";')
    w("}")
    w("")
    w("float wrapper_param_min(GenState* state, int index) {")
    w("    (void)state;")
    w(f"    return {name}_param_min(index);")
    w("}")
    w("")
    w("float wrapper_param_max(GenState* state, int index) {")
    w("    (void)state;")
    w(f"    return {name}_param_max(index);")
    w("}")
    w("")
    w("char wrapper_param_hasminmax(GenState* state, int index) {")
    w("    (void)state; (void)index;")
    w("    return 1;")
    w("}")
    w("")
    w("void wrapper_set_param(GenState* state, int index, float value) {")
    w(f"    {name}_set_param(({struct}*)state, index, value);")
    w("}")
    w("")
    w("float wrapper_get_param(GenState* state, int index) {")
    w(f"    return {name}_get_param(({struct}*)state, index);")
    w("}")
    w("")

    # -- buffers
    w(f"int wrapper_num_buffers() {{ return {name}_num_buffers(); }}")
    w("")
    w("const char* wrapper_buffer_name(int index) {")
    w(f"    return {name}_buffer_name(index);")
    w("}")
    w("")
    w("} // namespace WRAPPER_NAMESPACE")
    w("")

    return "\n".join(lines)


def generate_manifest(graph: Graph) -> str:
    """Generate a ``manifest.json`` compatible with gen-dsp's ``Manifest``.

    Args:
        graph: The DSP graph.

    Returns:
        JSON string.
    """
    from dsp_graph import __version__

    buffer_ids = [n.id for n in graph.nodes if isinstance(n, Buffer)]
    data = {
        "gen_name": graph.name,
        "num_inputs": len(graph.inputs),
        "num_outputs": len(graph.outputs),
        "params": [
            {
                "index": i,
                "name": p.name,
                "has_minmax": True,
                "min": p.min,
                "max": p.max,
                "default": p.default,
            }
            for i, p in enumerate(graph.params)
        ],
        "buffers": buffer_ids,
        "source": "dsp-graph",
        "version": __version__,
    }
    return json.dumps(data, indent=2) + "\n"


def compile_for_gen_dsp(
    graph: Graph,
    output_dir: str | Path,
    platform: str,
) -> Path:
    """Compile a graph and generate gen-dsp adapter files.

    Writes three files to *output_dir*:

    - ``{name}.cpp`` -- compiled dsp-graph C++
    - ``_ext_{platform}.cpp`` -- gen-dsp adapter
    - ``manifest.json`` -- gen-dsp-compatible manifest

    Args:
        graph: The DSP graph.
        output_dir: Where to write files.
        platform: gen-dsp platform key.

    Returns:
        Path to the output directory.
    """
    out = Path(output_dir)
    out.mkdir(parents=True, exist_ok=True)

    code = compile_graph(graph)
    (out / f"{graph.name}.cpp").write_text(code)

    adapter = generate_adapter_cpp(graph, platform)
    (out / f"_ext_{platform}.cpp").write_text(adapter)

    manifest = generate_manifest(graph)
    (out / "manifest.json").write_text(manifest)

    return out


def assemble_project(
    graph: Graph,
    output_dir: str | Path,
    platform: str,
) -> Path:
    """Assemble a complete buildable gen-dsp project.

    Combines dsp-graph output with gen-dsp platform template files
    so the result can be built with gen-dsp's build system.

    Requires ``gen_dsp`` to be installed.

    Args:
        graph: The DSP graph.
        output_dir: Where to assemble the project.
        platform: gen-dsp platform key.

    Returns:
        Path to the assembled project directory.
    """
    out = Path(output_dir)

    # 1. Generate dsp-graph files
    compile_for_gen_dsp(graph, out, platform)

    # 2. Copy platform template files
    _copy_platform_templates(out, platform)

    # 3. Generate gen_buffer.h (no buffers for dsp-graph -- it manages them internally)
    _generate_buffer_header(out)

    return out


def _copy_platform_templates(output_dir: Path, platform: str) -> None:
    """Copy gen-dsp platform template files to the output directory."""
    import gen_dsp.templates as templates  # type: ignore[import-untyped]

    getter = getattr(templates, f"get_{platform}_templates_dir", None)
    if getter is None:
        raise ValueError(f"No gen-dsp template directory for platform {platform!r}")

    tmpl_dir = getter()
    if not tmpl_dir.is_dir():
        raise FileNotFoundError(f"Template directory not found: {tmpl_dir}")

    # Files to copy (platform-side code + interface header + common header)
    targets = [
        f"gen_ext_{platform}.cpp",
        f"gen_ext_common_{platform}.h",
        f"_ext_{platform}.h",
    ]

    for fname in targets:
        src = tmpl_dir / fname
        if src.is_file():
            shutil.copy2(src, output_dir / fname)

    # Copy platform-specific extras
    if platform == "chuck":
        # chugin.h bundle
        chugin_src = tmpl_dir / "chuck" / "include" / "chugin.h"
        if chugin_src.is_file():
            dest = output_dir / "chuck" / "include"
            dest.mkdir(parents=True, exist_ok=True)
            shutil.copy2(chugin_src, dest / "chugin.h")

        # makefile templates
        for mf in ("makefile.mac", "makefile.linux"):
            src = tmpl_dir / mf
            if src.is_file():
                shutil.copy2(src, output_dir / mf)


def _generate_buffer_header(output_dir: Path) -> None:
    """Generate a gen_buffer.h with zero buffers (dsp-graph manages its own)."""
    content = (
        "// gen_buffer.h -- auto-generated by dsp-graph\n"
        "#ifndef GEN_BUFFER_H\n"
        "#define GEN_BUFFER_H\n"
        "\n"
        "#define WRAPPER_BUFFER_COUNT 0\n"
        "\n"
        "#endif // GEN_BUFFER_H\n"
    )
    (output_dir / "gen_buffer.h").write_text(content)
